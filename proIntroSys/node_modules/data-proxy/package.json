{
  "name": "data-proxy",
  "description": "Data communication with a backend",
  "version": "0.5.5",
  "author": {
    "name": "Matias Meno",
    "email": "m@tias.me"
  },
  "dependencies": {
    "coffee-script": "1.x",
    "q": "0.x"
  },
  "devDependencies": {
    "mocha": "*",
    "coffee-script": "*",
    "should": "*"
  },
  "main": "index",
  "scripts": {
    "test": "make test"
  },
  "engines": {
    "node": "0.x"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/enyo/data-proxy.git"
  },
  "homepage": "https://github.com/enyo/data-proxy",
  "readme": "# Data proxy Version 0.5.5\n\n\nThe data proxy is a node module that has pretty complex schema/model definition capabilities to automatically receive\nand transmit data in a formatted and validated form.\n\nI wrote this so you can easily submit data sent from an untrusted browser form to a backend that receives trusted JSON.\n\nIt helps validate that all defined properties are set and the right type, and formats the JSON correctly.\n\n\n\nI use [semantic versioning][] and my [tag script][] to tag this module.\n\nThe library is fully tested with the [mocha test framework][] and the [should assertion library][]. If you contribute\nplease make sure that you write tests for it.\n\n\n[semantic versioning]: http://semver.org/\n[tag script]: https://github.com/enyo/tag\n[mocha test framework]: http://visionmedia.github.com/mocha/\n[should assertion library]: https://github.com/visionmedia/should.js\n\n\nThe latest **stable** version is always in the `master` branch. The `develop` branch is\ncutting edge where tests regularely won't completely pass. Only checkout the `develop` branch\nif you want to contribute.\n\n\n## Installation\n\nSimply install via [npm][]:\n\n    npm install data-proxy\n\nor download the latest manually, and put it in `node_modules`.\n\n[npm]: http://npmjs.org\n\n## Configuration\n\nSimply call `dataProxy.configure()` to configure the proxy:\n\n    var dataProxy = require(\"data-proxy\");\n    dataProxy.configure({\n        host: '10.0.0.100'\n      , protocol: 'https'\n      , port: 443\n      , pathPrefix: '/some/path' // Without trailing slash\n      , queryStringSeparator: '&'\n      , debug: false\n    });\n\n> The `pathPrefix` should not have a trailing slash.\n\n\n## Define your schema\n\nThe first part to do is define your schema.  \nA schema definition could look something like this:\n\n    // /models/user.js\n  \n    var Schema = require('data-proxy').Schema\n      , Checked = require('data-proxy').checked_types;\n\n    var UserSchema = new Schema({\n        id: Checked.Number // Since normally you simply insert the data submitted by a form, it can happen that a user\n                           // submits an ID referencing an entity that does not belong to her/him. To ensure that all\n                           // those are IDs are checked the «Checked.» types are used. Those attributes can't simply be\n                           // generated from a submitted String (as all other attributes are), but have to be set\n                           // programatically.\n      , username_: String // The trailing _ means that it is required\n      , password: String\n      , $trusted: Boolean // The $ prefix means that this variable is private and should never be sent to the user\n      , memberSince: Date\n      , address: {\n            street: String\n          , city: String\n          , countryId: Number\n        }\n      , friendIds: [Number]\n      , favoriteFoods: [{\n            name: String\n          , recipe: {\n              difficulty: Number\n            , instructions: String\n          }\n        }]\n    });\n\n    // Export the User model\n    module.exports = UserSchema.model('User');\n\nAnd to validate and handle that model:\n\n    // Somewhere inside your app:\n    var User = require(\"./models/user\");\n\n    // This call automatically validates the object and throws an exception if it's invalid.\n    var user = new User({ username: \"sexy82\", address: { street: \"Downtownstreet 37\" } });\n\nIf you want to handle errors differently you can pass a errorCallback:\n\n    // During initialization\n    var user = new User({ }, function(path, errorCode) {\n      // handle the error\n    });\n    // or set the data\n    var user = new User()\n      , skipValidation = false;\n\n    user.setData({ }, function(path, errorCode) { }, skipValidation);\n\nWhere `path` is the path of the key/value that caused the error starting with the model name (e.g.: User.address.city),\nand `errorCode` is one of:\n\n  - `Model.INVALID_VALUE` if the object provided an invalid value\n  - `Model.INVALID_KEY` if the object provided an invalid key\n  - `Model.UNDEFINED_KEY` if a required key was not provided\n  - `Model.UNDEFINED_VALUE` if a required value was not provided\n\n\n## Usage\n\nActually post a request:\n\n    // dataProxy.post(path, body, successCallback, errorCallback);\n    // Example:\n    dataProxy.post(\n        '/path/to/post'\n      , { body: { some: \"data\", to: \"post\", as: \"json\" } })\n    .then(function(response) {\n      // Success\n    })\n    .fail(function(err) {\n      // Error (If the server responded with 40x oder 50x, or if the JSON was invalid.)\n      // The server response is inside `err.response`\n    );\n\n\n`response` is an object containing following information:\n\n- `response.statusCode` The http status code returned (e.g.: `404`).\n- `response.headers` An array of the headers returned.\n- `response.data` Contains the data returned by the server.\n- `response.dataObject` (optional) Contains the parsed data (if any) returned by the server.\n- `response.record` (optional) If you specified the `receiveAs` option.\n\n> If the `content-type` submitted by the server is  `application-json` then the data will automatically be parsed and is\n> accessible via `response.dataObject`.\n\n\nIf you expect to receive a specific model, you can pass the `receiveAs` option. You will then receive the record in\nthe response as `response.record`. **The `dataObject` will then be the sanitized version of the data!**\n\n    // Example:\n    var User = require(\"./models/user\");\n    dataProxy.post(\n        '/path/to/post'\n      , { receiveAs: User })\n    .then(function(response) {\n      // Success\n      // response.record is a user document, filled with the received and sanitized data.\n    })\n    .fail(function(err) {\n      // Error\n    });\n\n\n## License\n\n(The MIT License)\n\nCopyright (c) 2012 Matias Meno &lt;m@tias.me&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\ndocumentation files (the 'Software'), to deal in the Software without restriction, including without limitation the\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the\nSoftware.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\nWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "Readme.md",
  "_id": "data-proxy@0.5.5",
  "dist": {
    "shasum": "d8f943820f516e4e4f9b5cdb8c17519a39bd641f",
    "tarball": "http://registry.npmjs.org/data-proxy/-/data-proxy-0.5.5.tgz"
  },
  "_npmVersion": "1.1.65",
  "_npmUser": {
    "name": "enyo",
    "email": "m@tias.me"
  },
  "maintainers": [
    {
      "name": "enyo",
      "email": "m@tias.me"
    }
  ],
  "directories": {},
  "_shasum": "d8f943820f516e4e4f9b5cdb8c17519a39bd641f",
  "_resolved": "https://registry.npmjs.org/data-proxy/-/data-proxy-0.5.5.tgz",
  "_from": "data-proxy@*"
}
